# We run this CI workflow so we can keep confidence in our backup tooling on every supported stack.
# The jobs cover build, migration, and multi-arch scenarios so we notice regressions before they reach production.
name: CI

on:
  push:
    branches:
      - main
  pull_request:

jobs:
  # We build the project across multiple Postgres and Alpine pairs to prove that our Docker image remains portable.
  image-build-matrix:
    name: Image build for Postgres ${{ matrix.pg_version }} on Alpine ${{ matrix.alpine_version }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - pg_version: 14
            # Alpine 3.20 still ships postgresql14-client, so we build on that baseline.
            alpine_version: "3.20"
          - pg_version: 15
            # Alpine 3.20 carries postgresql15-client as well, keeping the matrix consistent with local defaults.
            alpine_version: "3.20"
          - pg_version: 16
            alpine_version: "3.20"
          - pg_version: 17
            alpine_version: "3.21"
          # We skip Postgres 18 for now because Alpine 3.22 does not yet publish postgresql18-client.
    steps:
      # We fetch the latest commit so every following step has the source we want to validate.
      - name: Checkout
        uses: actions/checkout@v4

      # We export the matrix inputs into the environment so downstream scripts compile the exact variant under test.
      - name: Configure build inputs
        run: |
          # We capture the matrix Alpine version so our Dockerfile picks the right base image for this run.
          echo "ALPINE_VERSION=${{ matrix.alpine_version }}" >> "$GITHUB_ENV"
          # We store the Postgres version so the compose build reuses the number without repeating matrix syntax.
          echo "POSTGRES_VERSION=${{ matrix.pg_version }}" >> "$GITHUB_ENV"

      # We invoke our shared build script so we compile and validate the image exactly the way teammates do locally.
      - name: Compose build
        run: scripts/build-image.sh

      # We exercise the schedule guardrail so `run.sh` keeps rejecting invalid cron strings inside the container.
      - name: Validate schedule failure path
        run: scripts/validate-schedule.sh

      # We guarantee the Prometheus endpoint stays reachable by spinning up the
      # container and scraping supercronic's /metrics handler.
      - name: Verify metrics endpoint
        run: scripts/metrics-smoke.sh

      # We confirm the default retention behaviour by exercising the backup flow against MinIO.
      - name: Verify backup retention default
        run: scripts/retention-smoke.sh

  # We verify in-place upgrades across every supported Postgres combination so restores stay reliable during rollouts.
  upgrade-smoke-matrix:
    name: Migrate ${{ matrix.from }} -> ${{ matrix.to }}
    runs-on: ubuntu-latest
    needs: image-build-matrix
    strategy:
      fail-fast: false
      matrix:
        include:
          - from: 14
            to: 15
          - from: 14
            to: 16
          - from: 14
            to: 17
          - from: 15
            to: 16
          - from: 15
            to: 17
          - from: 16
            to: 17
          # We skip Postgres 18 migrations until Alpine publishes client packages for that major.
    steps:
      # We pull the repository again so this job has a clean workspace tied to the migration matrix entry.
      - name: Checkout
        uses: actions/checkout@v4

      # We run the smoke test so we can confirm that upgrades, dumps, and restores succeed for this pair.
      - name: Run migration smoke
        env:
          FROM_VERSION: ${{ matrix.from }}
          TO_VERSION: ${{ matrix.to }}
        run: scripts/migration-smoke.sh

  # We assemble multi-architecture images so our releases work on both AMD64 and ARM64 builders.
  multi-arch-image:
    name: Multi-arch build (${{ matrix.platform }})
    runs-on: ubuntu-latest
    needs: image-build-matrix
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: linux/amd64
            supercronic_sha: 53a484404b0c559d64f78e9481a3ec22f782dc46
          - platform: linux/arm64
            supercronic_sha: 58b3c15304e7b59fe7b9d66a2242f37e71cf7db6
    steps:
      # We clone the repo for this job so the build context mirrors the tarball we ship.
      - name: Checkout
        uses: actions/checkout@v4

      # We enable QEMU emulation so Docker Buildx can synthesize the non-native architecture locally.
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      # We initialize Buildx so we can target multiple architectures with one configuration.
      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      # We build the image tarball on the requested platform so both architectures stay in lock-step.
      - name: Build image
        env:
          PLATFORM: ${{ matrix.platform }}
          SUPERCRONIC_SHA1SUM: ${{ matrix.supercronic_sha }}
        run: |
          # We compile the Docker image for the chosen platform and skip provenance artifacts to keep CI fast.
          docker buildx build \
            --platform "$PLATFORM" \
            --build-arg ALPINE_VERSION=3.20 \
            --build-arg POSTGRES_VERSION=16 \
            --build-arg SUPERCRONIC_SHA1SUM="$SUPERCRONIC_SHA1SUM" \
            --progress plain \
            --provenance=false \
            --sbom=false \
            --output "type=tar,dest=build-${PLATFORM//\//-}.tar" .
          # We discard the tarball after the build completes so CI storage stays lean.
          rm -f "build-${PLATFORM//\//-}.tar"
